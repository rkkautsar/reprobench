# generated by 'lingeling --pcs-reduced'
# version bcj 78ebb8672540bde0a335aea946bbf32515157d5a
activity {0,1,2}[0] # activity based clause reduction
agility {0,1}[1] # enable agility based restart skipping
bate {0,1}[1] # basic ATE removal during probing
batewait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
bca {0,1,2}[0] # enable blocked clause addition (1=weak,2=strong)
bcawait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
bkwdresched {0,1}[1] # reschedule variables during backward
blklarge {0,1}[1] # BCE of large clauses
blkresched {0,1}[1] # reschedule tried but failed literals
blkrtc {0,1}[0] # run BCE until completion
blksmall {0,1}[1] # BCE of small clauses
block {0,1}[0] # blocked clause elimination (BCE)
blockwait {0,1}[1] # wait for BVE
boost {0,1}[1] # enable boosting of preprocessors
bumpreasonlits {0,1}[1] # bump reason literals too
bumpsimp {0,1}[0] # bump during simplification too
card {0,1}[1] # cardinality constraint reasoning
cardcut {0,1,2}[2] # 1=gomoroy-cuts,2=strengthen
cardignused {0,1}[0] # ignore already used literals in extraction
carduse {0,1,2,3}[2] # use clauses (1=oneside,2=bothsidetoo,3=anyside)
cardwait {0,1,2}[0] # wait for BCE (1) and/or BVE (2)
classify {0,1,2,3}[2] # classifier for parameter setting
cce {0,1,2,3}[3] # covered clause elimination (1=ate,2=abce,3=acce)
ccertc {0,1,2}[0] # run CCE until completition (1=almost-no-limit)
ccewait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
compact {0,1,2}[0] # compactify after 'lglsat/lglsimp' (1=UNS,2=SAT)
deco {0,1}[1] # learn decision-only clauses too
deco1opt {0,1}[1] # optimized deco 1
decompose {0,1}[1] # enable decompose
elim {0,1}[1] # bounded variable eliminiation (BVE)
elmblk {0,1}[1] # enable BCE during BVE
elmblkwait {0,1}[1] # wait for BVE to be completed once
elmfull {0,1}[0] # no elimination limits
elmrtc {0,1,2}[0] # run BVE until completion (1=almost-no-limit)
elmotfstr {0,1}[1] # on-the-fly strengthening during BVE
elmotfsub {0,1}[1] # on-the-fly subsumption during BVE
factor {0,1,2,3}[3] # {cls,occ}lim factors (0=const1,1=ld,2=lin,3=sqr)
gauss {0,1}[1] # enable gaussian elimination
gausscardweak {0,1}[1] # extract XOR from cardinality constraints
gaussexptrn {0,1}[1] # export trn cls from gaussian elimination
gaussextrall {0,1}[1] # extract all xors (with duplicates)
gausswait {0,1,2}[2] # wait for BCE (1) and/or BVE (2) for XOR extraction
gluescale {1,2,3,4,5}[4] # glue scaling: 1=ar1,2=ar2,3=sqrt,4=sqrtld,5=ld
hbrdom {0,1,2}[2] # 0=root-impl-tree,1=lca-impl-tree,2=lca-big-dag
import {0,1}[1] # import external indices and map them
incsavevisits {0,1}[0] # incremental start new visits counter
inprocessing {0,1}[1] # enable inprocessing
irrlim {0,1}[1] # use irredundant clauses as limit for simps
jwhred {0,1,2}[1] # JWH score based on redundant clauses too (2=only)
keepmaxglue {0,1}[1] # keep maximum glue clauses
lhbr {0,1}[1] # enable lazy hyber binary reasoning
lkhd {-1,0,1,2,3}[2] # -1=LOCS,0=LIS,1=JWH,2=TREELOOK,3=LENSUM
locsbanner {0,1}[0] # print version number of LOCS component
locset {0,1,2}[2] # initialize local search phases (1=prev,2=cur)
locsexport {0,1}[1] # export phases from local search
locsred {0,1,2,3,4}[0] # apply local search on redundant clauses too
locsrtc {0,1}[0] # run local search until completion
locswait {0,1,2}[2] # wait for BCE(1) and/or BVE(2)
minimize {0,1,2}[2] # minimize learned clauses (1=local,2=recursive)
move {0,1,2}[2] # move redundant cls (1=only-binary,2=ternary-too)
otfs {0,1}[0] # enable on-the-fly subsumption
phase {-1,0,1}[0] # default initial phase (-1=neg,0=JeroslowWang,1=pos)
phasesave {-1,0,1}[1] # save and use previous phase (-1=reverse)
plain {0,1}[0] # plain mode disables all preprocessing
poison {0,1}[1] # poison optimization for clause minimization
prbasic {0,1,2}[1] # enable basic probing procedure (1=roots-only)
prbasicrtc {0,1}[0] # run basic probing until completion
prbrtc {0,1}[0] # run all probing until completion
prbsimple {0,1,2,3}[2] # simple probing (1=shallow,2=deep,3=touchall)
prbsimpleliftdepth {1,2,3,4}[2] # simple probing lifting depth
prbsimplertc {0,1}[0] # run simple probing until completion
probe {0,1}[1] # enable probing
profile {0,1,2,3,4}[1] # profile level
profilelong {0,1}[0] # print long profile information
promote {0,1}[1] # keep clauses with reduced glue longer
prune {0,1}[0] # pruning through satisfication
# --> {0, 1}
prunepure {0,1}[1] # find and treat pure literals explicitly
prunered {0,1}[1] # learned pruning clauses as redundant clauses
prunevsids {0,1}[0] # pruning decisions using default heuristic
pure {0,1}[1] # enable pure literal elimination during BCE
quatres {0,1}[1] # enable quaternay resolution
quatreswait {0,1,2}[2] # wait with quaternay resolution
queuesort {0,1}[1] # sort decision queue by JWH score
randec {0,1}[0] # enable random decisions order
randphase {0,1}[0] # enable random decision phases
redcls {0,1}[1] # reduce literals in learned clauses
redclstype {2,3,4}[4] # type of clauses used for reduction
reduce {0,1}[1] # enable clause reduction
reducefixed {0,1}[0] # enabled fixed bound on learned clauses
reducereset {0,1,2}[0] # enable reduce increment reset
restart {0,1}[1] # enable restarting
restartfixed {0,1}[0] # fixed restart
restartblock {0,1,2}[0] # enable restart blocking (1=conflict,2=restart)
restartcheckforced {0,1}[1] # enable skipping restarts if not forced
restartdelay {0,1}[1] # enable restart delaying based on jump level
restartforcemode {0,1,2}[1] # forced restart mode (0=avg,1=ema,2=macd)
restartpen1 {0,1}[1] # increase restart interval if few units
restartpen2 {0,1}[1] # increase restart interval if few binary clauses
restartpen3 {0,1}[1] # increase restart interval if few ternary clauses
restartpenstab {0,1}[1] # increase restart interval if stabilizing
retirenb {0,1}[1] # enabled inactive clause retirement
reusetrail {0,1}[1] # reuse trail
scincincmode {0,1,2}[1] # score inc inc mode (0=keep,1=delta,2=avg)
simpcintincdiv {0,1,2,3}[1] # cintinc reduction: 0=no,1=div1,2=div2,3=heur
simpintsizepen {0,1}[0] # penalize interval (positively) by size
simpjleveldecdelay {0,1}[1] # delay simp if jlevel decreases
simpitintdecdelay {0,1}[1] # delay simp if iteration interval decreases
simplify {0,1,2}[2] # enable simplification
# --> {0,1,2}
smallve {0,1}[1] # enable small number variables elimination
smallvewait {0,1}[0] # wait with small variable elimination
sortlits {0,1}[0] # sort lits of cls during garbage collection
sweep {0,1}[1] # enabled SAT sweeping
sweepirr {0,1,2,3}[3] # irredundant clauses (1=bin,2=trn,3=lrg)
sweepred {0,1,2,3}[3] # include redundant clauses (1=bin,2=trn,3=lrg)
sweeprtc {0,1}[0] # run sweeping until completion
sweepwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
synclsall {0,1}[1] # always synchronize all unconsumed clauses
ternres {0,1}[1] # generate ternary resolvents
ternresrtc {0,1}[0] # run ternary resolvents until completion
ternreswait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
transred {0,1}[1] # enable transitive reduction
transredwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
trapiflush {0,1}[0] # flush API trace after each call
treelook {0,1,2}[1] # enable tree-based look-ahead (2=scheduleprobing)
treelookfull {0,1}[0] # do not limit tree-based look-head
treelookrtc {0,1}[0] # run tree-based look-ahead until completion
trep {0,1}[0] # enable time based interval reporting
unhdatrn {0,1,2}[2] # unhide redundant ternary clauses (1=move,2=force)
unhdextstamp {0,1}[1] # used extended stamping features
unhdhbr {0,1}[0] # enable unhiding hyper binary resolution
unhide {0,1}[1] # enable unhiding
unhidewait {0,1,2}[0] # wait for BCE (1) and/or BVE (2)
usedtwice {0,1}[1] # used twice optimization for clause minimization
wait {0,1}[1] # enable or disable all waiting
